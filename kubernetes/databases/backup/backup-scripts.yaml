# =============================================================================
# ConfigMap - Backup Scripts
# =============================================================================
# Scripts utilitaires pour les operations de backup et restore.
# Montes dans les CronJobs et disponibles en exec dans les pods.
# =============================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-scripts
  namespace: backup
  labels:
    app: backup
    app.kubernetes.io/name: backup-scripts
    app.kubernetes.io/part-of: backup
  annotations:
    description: "Scripts de backup, restore et verification pour PostgreSQL et Redis"
data:
  # -------------------------------------------------------------------------
  # Verification de l'integrite des backups PostgreSQL
  # -------------------------------------------------------------------------
  verify-pg-backup.sh: |
    #!/bin/bash
    set -euo pipefail
    echo "============================================"
    echo "  Verification backup PostgreSQL"
    echo "  $(date '+%Y-%m-%d %H:%M:%S')"
    echo "============================================"

    export AWS_S3_FORCE_PATH_STYLE="true"
    export AWS_REGION="fsn1"

    # Lister les backups disponibles
    echo ""
    echo "[1/3] Backups disponibles:"
    wal-g backup-list 2>/dev/null || {
      echo "ERREUR: Impossible de lister les backups"
      exit 1
    }

    # Verifier le dernier backup
    echo ""
    echo "[2/3] Detail du dernier backup:"
    LAST_BACKUP=$(wal-g backup-list 2>/dev/null | tail -1 | awk '{print $1}')
    if [ -n "$LAST_BACKUP" ]; then
      echo "  Nom: $LAST_BACKUP"
      # Verifier l'integrite via WAL-G
      wal-g backup-verify "$LAST_BACKUP" 2>/dev/null || echo "  WARNING: Verification integrite non supportee"
    else
      echo "  ERREUR: Aucun backup trouve"
      exit 1
    fi

    # Verifier la continuite des WAL
    echo ""
    echo "[3/3] Verification continuite WAL:"
    wal-g wal-verify integrity 2>/dev/null || echo "  INFO: Verification WAL integrity non disponible"

    echo ""
    echo "============================================"
    echo "  Verification terminee"
    echo "============================================"

  # -------------------------------------------------------------------------
  # Restore PostgreSQL (PITR)
  # -------------------------------------------------------------------------
  restore-postgresql.sh: |
    #!/bin/bash
    set -euo pipefail

    TARGET_TIME="${1:-}"
    RESTORE_MODE="${2:-latest}"

    echo "============================================"
    echo "  Restore PostgreSQL"
    echo "  $(date '+%Y-%m-%d %H:%M:%S')"
    echo "============================================"

    if [ "$RESTORE_MODE" = "pitr" ] && [ -z "$TARGET_TIME" ]; then
      echo "Usage: restore-postgresql.sh <target-time> pitr"
      echo "  Exemple: restore-postgresql.sh '2024-01-15 14:30:00' pitr"
      exit 1
    fi

    export AWS_S3_FORCE_PATH_STYLE="true"
    export AWS_REGION="fsn1"

    echo ""
    echo "ATTENTION: Cette operation va REMPLACER les donnees actuelles !"
    echo "Mode: $RESTORE_MODE"
    if [ -n "$TARGET_TIME" ]; then
      echo "Target time: $TARGET_TIME"
    fi
    echo ""

    # Etape 1: Arreter le StatefulSet
    echo "[1/5] Arret du StatefulSet PostgreSQL..."
    kubectl scale statefulset postgresql -n production --replicas=0
    sleep 10

    # Etape 2: Nettoyer le volume de donnees
    echo "[2/5] Preparation du volume de donnees..."
    # Ce step doit etre fait manuellement ou via un Job specifique

    # Etape 3: Restaurer
    echo "[3/5] Restauration depuis S3..."
    if [ "$RESTORE_MODE" = "pitr" ]; then
      echo "  PITR vers: $TARGET_TIME"
      wal-g backup-fetch LATEST --restore-spec "{ \"restore_command\": \"wal-g wal-fetch %f %p\", \"recovery_target_time\": \"$TARGET_TIME\" }"
    else
      echo "  Restauration du dernier backup complet..."
      wal-g backup-fetch LATEST
    fi

    # Etape 4: Configurer recovery
    echo "[4/5] Configuration du recovery..."
    # Patroni gerera le recovery automatiquement au redemarrage

    # Etape 5: Redemarrer
    echo "[5/5] Redemarrage du StatefulSet..."
    kubectl scale statefulset postgresql -n production --replicas=2

    echo ""
    echo "============================================"
    echo "  Restore lance - verifier avec:"
    echo "  kubectl logs -n production postgresql-0 -f"
    echo "============================================"

  # -------------------------------------------------------------------------
  # Restore Redis depuis S3
  # -------------------------------------------------------------------------
  restore-redis.sh: |
    #!/bin/bash
    set -euo pipefail

    DUMP_FILE="${1:-latest}"

    echo "============================================"
    echo "  Restore Redis"
    echo "  $(date '+%Y-%m-%d %H:%M:%S')"
    echo "============================================"

    export AWS_S3_FORCE_PATH_STYLE="true"
    export AWS_REGION="fsn1"

    # Lister les dumps disponibles
    echo "[1/4] Dumps Redis disponibles sur S3:"
    aws s3 ls "s3://${S3_BUCKET}/redis/snapshots/" \
      --endpoint-url "${AWS_ENDPOINT}" \
      --region fsn1

    if [ "$DUMP_FILE" = "latest" ]; then
      DUMP_FILE=$(aws s3 ls "s3://${S3_BUCKET}/redis/snapshots/" \
        --endpoint-url "${AWS_ENDPOINT}" --region fsn1 | \
        sort | tail -1 | awk '{print $4}')
      echo "  Dernier dump: $DUMP_FILE"
    fi

    # Telecharger le dump
    echo "[2/4] Telechargement de $DUMP_FILE..."
    aws s3 cp "s3://${S3_BUCKET}/redis/snapshots/$DUMP_FILE" /tmp/dump.rdb \
      --endpoint-url "${AWS_ENDPOINT}" --region fsn1

    echo "[3/4] Arret de Redis et restauration..."
    echo "  MANUEL: Arreter Redis, copier le dump.rdb, redemarrer"
    echo "  kubectl scale statefulset redis -n production --replicas=0"
    echo "  # Copier /tmp/dump.rdb vers le volume Redis"
    echo "  kubectl scale statefulset redis -n production --replicas=3"

    echo "[4/4] Verification..."
    echo "  kubectl exec -n production redis-0 -- redis-cli -a \$REDIS_PASSWORD dbsize"

    echo ""
    echo "============================================"
    echo "  Dump telecharge: /tmp/dump.rdb"
    echo "============================================"

  # -------------------------------------------------------------------------
  # Rapport de sante des backups
  # -------------------------------------------------------------------------
  backup-health-report.sh: |
    #!/bin/bash
    set -euo pipefail
    echo "============================================"
    echo "  Rapport Sante Backups"
    echo "  $(date '+%Y-%m-%d %H:%M:%S')"
    echo "============================================"

    ERRORS=0

    # PostgreSQL backups
    echo ""
    echo "--- PostgreSQL WAL-G ---"
    PG_BACKUPS=$(wal-g backup-list 2>/dev/null | grep -c "base_" || echo "0")
    LAST_PG=$(wal-g backup-list 2>/dev/null | tail -1 || echo "aucun")
    echo "  Backups: $PG_BACKUPS"
    echo "  Dernier: $LAST_PG"
    if [ "$PG_BACKUPS" -lt 1 ]; then
      echo "  ERREUR: Aucun backup PostgreSQL !"
      ((ERRORS++))
    fi

    # Redis backups
    echo ""
    echo "--- Redis RDB ---"
    REDIS_BACKUPS=$(aws s3 ls "s3://${S3_BUCKET}/redis/snapshots/" \
      --endpoint-url "${AWS_ENDPOINT}" --region fsn1 2>/dev/null | wc -l || echo "0")
    LAST_REDIS=$(aws s3 ls "s3://${S3_BUCKET}/redis/snapshots/" \
      --endpoint-url "${AWS_ENDPOINT}" --region fsn1 2>/dev/null | sort | tail -1 || echo "aucun")
    echo "  Snapshots: $REDIS_BACKUPS"
    echo "  Dernier: $LAST_REDIS"
    if [ "$REDIS_BACKUPS" -lt 1 ]; then
      echo "  ERREUR: Aucun backup Redis !"
      ((ERRORS++))
    fi

    # Espace S3 utilise
    echo ""
    echo "--- Espace S3 ---"
    aws s3 ls "s3://${S3_BUCKET}/" --summarize --recursive \
      --endpoint-url "${AWS_ENDPOINT}" --region fsn1 2>/dev/null | tail -2 || echo "  Impossible de calculer"

    echo ""
    echo "============================================"
    if [ $ERRORS -eq 0 ]; then
      echo "  Status: OK"
    else
      echo "  Status: $ERRORS ERREUR(S)"
    fi
    echo "============================================"
    exit $ERRORS
