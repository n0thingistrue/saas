# =============================================================================
# CronJob - PostgreSQL WAL-G Push (archivage continu)
# =============================================================================
# Archive les WAL segments vers S3 Hetzner en continu.
# En complement de l'archive_command Patroni (qui archive chaque WAL segment),
# ce CronJob verifie regulierement qu'aucun WAL n'a ete manque
# et force un checkpoint + push si necessaire.
#
# Frequence : toutes les 15 minutes
# Garantit RPO < 15 minutes (objectif RNCP)
#
# Ne s'execute que sur le primary (verifie via Patroni API).
# =============================================================================
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgresql-wal-push
  namespace: backup
  labels:
    app: postgresql-backup
    component: wal-push
    app.kubernetes.io/name: postgresql-backup
    app.kubernetes.io/component: wal-push
    app.kubernetes.io/part-of: backup
  annotations:
    description: "Verification et push des WAL PostgreSQL vers S3 toutes les 15min"
spec:
  schedule: "*/15 * * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 5
  startingDeadlineSeconds: 120
  jobTemplate:
    spec:
      backoffLimit: 2
      activeDeadlineSeconds: 600
      template:
        metadata:
          labels:
            app: postgresql-backup
            component: wal-push
        spec:
          restartPolicy: OnFailure
          containers:
            - name: wal-push
              image: bitnami/postgresql:16
              command:
                - /bin/bash
                - -c
                - |
                  set -euo pipefail
                  echo "[WAL-PUSH] $(date '+%Y-%m-%d %H:%M:%S') Verification archivage WAL..."

                  # Verifier que le primary est accessible
                  PRIMARY_HOST="postgresql-primary.production.svc.cluster.local"

                  # Verifier via Patroni que c'est bien le primary
                  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${PRIMARY_HOST}:8008/primary" 2>/dev/null || echo "000")
                  if [ "$HTTP_CODE" != "200" ]; then
                    echo "[WAL-PUSH] Le primary n'est pas accessible (HTTP $HTTP_CODE). Skip."
                    exit 0
                  fi

                  # Forcer un checkpoint pour flusher les WAL en attente
                  echo "[WAL-PUSH] Force checkpoint sur le primary..."
                  PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "$PRIMARY_HOST" -U postgres -c "CHECKPOINT;" 2>/dev/null || true

                  # Verifier le dernier backup WAL-G
                  echo "[WAL-PUSH] Verification du dernier backup..."
                  export WALG_S3_PREFIX="${WALG_S3_PREFIX}"
                  export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
                  export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
                  export AWS_ENDPOINT="${AWS_ENDPOINT}"
                  export AWS_S3_FORCE_PATH_STYLE="true"
                  export AWS_REGION="fsn1"

                  # Lister les backups pour verification
                  wal-g backup-list 2>/dev/null || echo "[WAL-PUSH] Impossible de lister les backups (premier run ?)"

                  echo "[WAL-PUSH] $(date '+%Y-%m-%d %H:%M:%S') Verification terminee"
              env:
                - name: POSTGRES_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: postgresql-credentials
                      key: POSTGRES_PASSWORD
                - name: WALG_S3_PREFIX
                  valueFrom:
                    secretKeyRef:
                      name: s3-credentials
                      key: WALG_S3_PREFIX
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: s3-credentials
                      key: AWS_ACCESS_KEY_ID
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: s3-credentials
                      key: AWS_SECRET_ACCESS_KEY
                - name: AWS_ENDPOINT
                  valueFrom:
                    secretKeyRef:
                      name: s3-credentials
                      key: AWS_ENDPOINT
              resources:
                requests:
                  cpu: 100m
                  memory: 128Mi
                limits:
                  cpu: 500m
                  memory: 512Mi
